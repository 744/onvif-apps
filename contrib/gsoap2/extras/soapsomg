#!/usr/bin/perl
use strict;
use Getopt::Long qw(:config no_ignore_case bundling);

print "===========================================================
gSOAP Server Side Operation Methods(wrapper) generator, v1.0
Webpage: https://github.com/varphone/onvif-apps
Contact: varphone wong, varphone\@qq.com
===========================================================

";

my $extension= ".c";
my @files = ();
my $help = 0;
my @includes = ();
my @includes_sys = ();
my $outdir = ".";
my $retval = "SOAP_NO_METHOD";
my $suffix = "-SSOM";

GetOptions(
  'extension|e=s' => \$extension,
  'file|f=s' => \@files,
  'help|h|?' => \$help,
  'include|include-local|i=s' => \@includes,
  'include-sys|I=s' => \@includes_sys,
  'outdir|o=s' => \$outdir,
  'retval|r=s' => \$retval,
  'suffix|s=s' => \$suffix,
);

sub showHelp() {
  print "Usage: ssomg --options
Options:
  -e, --extension [.c]          Setting code source file extension.
  -f, --file                    Add StubHeader file to processing list.
  -h, --help                    Show help message.
  -i, --include                 Add include header.
      --inclde-local            Add include header(local path).
  -I, --include-sys             Add include header(system path).
  -o, --outdir [.]              Setup output directory.
  -r, --retval [SOAP_NO_MTHOD]  Setup default return value.
  -s, --suffix [SSOM]           Setup source file suffix.
Examples:
  ssomg -f soapStub.h -i soapH.h
  ssomg --file soapStub.h --include soapH.h --suffix=-myssom
        --extension=.cpp --outdir out --retval SOAP_ERROR
";
}

sub probeNamespaces($$@) {
  my @result = ();
  my $srcFile = shift;
  my $lines = shift;
  foreach my $line (@$lines) {
    if ($line =~ m/SOAP_NAMESPACE_OF_/) {
      chop($line);
      $line =~ s/^(.*)\s+SOAP_NAMESPACE_OF_([^\s]*)\s+.*$/$2/;
      push(@result, $line);
      print "Namespace: $line probed.\n";
    }
  }
  return @result;
}

sub printHeader($) {
  my $parser = shift;
  print {$parser->{fd}} "/* $parser->{ns}${suffix}${extension}
   Generated by gSOAP Server Side Operation Methods(wrapper) generator v1.0
   from $parser->{srcFile}

Copyright(C) 2012, Varphone Wong, No.55 DP. CETC Group. All Rights Reserved.
The generated code is released under one of the following licenses:
1) GPL or 2) Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

";
  foreach my $i (@includes_sys) {
    print {$parser->{fd}} "#include <$i>\n";
  }
  foreach my $i (@includes) {
    print {$parser->{fd}} "#include \"$i\"\n";
  }
  my $src = $parser->{srcFile};
  $src =~ s/[^\/]*\/(.*)/$1/;
  print {$parser->{fd}} "#include \"${src}\"\n";
  print {$parser->{fd}} "\n";
}

sub printFooter($) {
}

sub printWrapperFunction($) {
  my $parser = shift;
  print {$parser->{fd}} "// Method: $parser->{ns}::$parser->{method}\n";
  print {$parser->{fd}} "$parser->{proto}
{
  //TODO: Place your code here.
  return ${retval};
}

";
}

sub generateOperationsForNS($) {
  my $parser = shift;
  $parser->{dstFile} = "$outdir/$parser->{ns}${suffix}${extension}";
  open $parser->{fd}, ">$parser->{dstFile}" or die "Unable to open: $parser->{dstFile}\n";
  print "Generating $parser->{dstFile} for $parser->{ns}.\n";
  printHeader $parser;
  foreach my $line (@{$parser->{lines}}) {
    if ($line =~ m/^SOAP_FMAC5 int SOAP_FMAC6 __$parser->{ns}__/) {
      $line =~ s/;\s*$//;
      my $method = $line;
      $method =~ s/^SOAP_FMAC5 int SOAP_FMAC6 __$parser->{ns}__([^\(]*).*/$1/;
      $line =~ s/struct soap\*/struct soap \*soap/;
      my $params = $line;      
      $params =~ s/[^\(]*\(([^)]*)\)*.*/$1/;
      my ($p1, $p2, $p3) = split(/,/, $params);
      my ($p1t, $p1v) = split(/ ([^ ]+)$/, $p1);
      my ($p2t, $p2v) = split(/ ([^ ]+)$/, $p2);
      my ($p3t, $p3v) = split(/ ([^ ]+)$/, $p3);
      $line =~ s/\Q$p2v/\*req/;
      $line =~ s/\Q$p3v/\*res/;      
      $parser->{method} = $method;
      $parser->{proto} = $line;
      printWrapperFunction $parser;
    }
  }
  printFooter $parser;
  close $parser->{fd};
}

sub parseFile($) {
  open(FD, $_[0]) or die("Unable to open: $_[0]\n");
  my @lines = <FD>;
  close(FD);
  my @nss = probeNamespaces $_[0], \@lines;
  foreach my $ns (@nss) {
    my %parser = ("srcFile" => $_[0],
      "lines" => \@lines,
      "ns" => $ns,
    );
    generateOperationsForNS \%parser;
  }
}

if ($help or not scalar(@files)) { showHelp() and exit; }

foreach my $file (@files) {
  print "Parsing file: $file.\n";
  parseFile($file);
}

