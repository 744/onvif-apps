#!/usr/bin/perl
use strict;
use Getopt::Long qw(:config no_ignore_case bundling);

print "===========================================================
gSOAP Server Side Operation Methods(wrapper) generator, v1.0
Webpage: https://github.com/varphone/onvif-apps
Contact: varphone wong, varphone\@qq.com
===========================================================

";

my $extension= ".c";
my @files = ();
my $help = 0;
my @includes = ();
my @includes_sys = ();
my $lang = 'c';
my @nsmap_files = ();
my $outdir = "";
my $retval = "SOAP_NO_METHOD";
my $suffix = "-SSOM";
my %namespaces = ();

GetOptions(
  'extension|e=s' => \$extension,
  'file|f=s' => \@files,
  'help|h|?' => \$help,
  'include|include-local|i=s' => \@includes,
  'include-sys|I=s' => \@includes_sys,
  'nsmap|n=s' => \@nsmap_files,
  'outdir|o=s' => \$outdir,
  'retval|r=s' => \$retval,
  'suffix|s=s' => \$suffix,
);

sub showHelp() {
  print "Usage: soapsomg --options
Options:
  -e, --extension [.c]          Setting code source file extension.
  -f, --file                    Add StubHeader file to processing list.
  -h, --help                    Show help message.
  -i, --include                 Add include header.
      --inclde-local            Add include header(local path).
  -I, --include-sys             Add include header(system path).
  -o, --outdir [.]              Setup output directory.
  -n, --nsmap          Add nsmap file to processing list.
  -r, --retval [SOAP_NO_MTHOD]  Setup default return value.
  -s, --suffix [SSOM]           Setup source file suffix.
Examples:
  soapsomg -f soapStub.h -n wsdd10.nsmap -i soapH.h
  soapsomg --file soapStub.h --include soapH.h --suffix=-myssom
           --extension=.cpp --outdir out --retval SOAP_ERROR
";
}

sub printHeader($) {
  my $parser = shift;
  print {$parser->{fd}} "/* $parser->{ns}${suffix}${extension}
   Generated by gSOAP Server Side Operation Methods(wrapper) generator v1.0
   from $parser->{srcFile}

Copyright(C) 2012, Varphone Wong, No.55 DP. CETC Group. All Rights Reserved.
The generated code is released under one of the following licenses:
1) GPL or 2) Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

";
  foreach my $i (@includes_sys) {
    print {$parser->{fd}} "#include <$i>\n";
  }
  foreach my $i (@includes) {
    print {$parser->{fd}} "#include \"$i\"\n";
  }
  my $src = $parser->{srcFile};
  $src =~ s/[^\/]*\/(.*)/$1/;
  print {$parser->{fd}} "#include \"${src}\"\n";
  print {$parser->{fd}} "\n";
}

sub printFooter($) {
}

sub printWrapperFunction($$@) {
  my $parser = shift;
  my $proto = shift;
  my $params = 0;
  print {$parser->{fd}} "// Method: $parser->{ns}::$proto->{name}\n";
  print {$parser->{fd}} "$proto->{decl} $proto->{return} $proto->{call} $proto->{name}(";
  foreach my $p (@{$proto->{params}}) {
    my %param = %{$p};
    print {$parser->{fd}} ",\n    " if $params > 0;
    my $v = $param{v};
    $v =~ s/([\*& ]*).*/${1}param${params}/ if $params > 0;
    print {$parser->{fd}} "$param{t} $v";
    $params++;
  }
  print {$parser->{fd}} ")
{
  //TODO: Place your code here.
  return ${retval};
}

";
}

sub parseLine($$@) {
  my $line = shift;
  my $ns = shift;
  my %proto = ();
  if ($line =~ m/^SOAP_FMAC5 int SOAP_FMAC6 __${ns}__/) {
    $line =~ s/;\s//;
    $line =~ s/struct soap\*/struct soap \*soap/;
    my ($decl, $return, $call) = split(/\ /, $line);
    my $name = $line;
    $name =~ s/.*\s+(__${ns}__[^\(]*)\(.*/$1/;
    my $params = $line;      
    $params =~ s/[^\(]*\(([^)]*)\)*.*/$1/;
    my @ps = split(/,/, $params);
    foreach my $p (@ps) {
      $p =~ s/^\s+//;
      my ($t, $v) = split(/ ([^ ]+)$/, $p);
      push @{$proto{params}}, { "p" => $p, "t" => $t, "v" => $v };
    }
    $proto{decl} = $decl;
    $proto{return} = $return;
    $proto{call} = $call;
    $proto{name} = $name;
    print "Found: $name\n";
  }
  return %proto;
}

sub parseLines($) {
  my $parser = shift;
  foreach my $line (@{$parser->{lines}}) {
    my %proto = parseLine $line, $parser->{ns};
    if (%proto) {
      printWrapperFunction $parser, \%proto;
    }
  }
}

sub detectLanguage($) {
  my $lines = shift;
  for (@{$lines}) { return "c++" if $_ =~ m/class\s+[^ ]*/; }
  return "c";
}

sub parseFile($) {
  my $file = shift;
  open FD, $file or die "Unable to open: $file\n";
  my @lines = <FD>;
  close(FD);
  my $lang = detectLanguage \@lines;
  die "Error: C++ does not supported.\n" if $lang =~ m/c\+\+/;
#  (my $amFile = $file) =~ s/\.[^.]+$/${suffix}\.am/;
  my $amFile = "ssom.am";
  open FD, ">$amFile" or die "Unable to open: $amFile";
#  (my $amVar = $file) =~ s/\.[^.]+$/_SOURCES/;
  print FD "ssom_SOURCES =";
  my @nss = keys %namespaces;
  foreach my $ns (@nss) {
    my %parser = ( srcFile => $file, lines => \@lines, ns => $ns );
    $parser{dstFile} = "$parser{ns}${suffix}${extension}";
    $parser{dstFile} =~ s/^/$outdir\// if $outdir;
    open $parser{fd}, ">$parser{dstFile}" or die "Unable to open: $parser{dstFile}\n";
    print FD "\\\n\t$parser{dstFile}";
    print "\n";
    print "Generating $parser{dstFile} for $parser{ns}.\n";
    printHeader \%parser;
    print "Server side methods for $ns:\n";
    parseLines \%parser;
    printFooter \%parser;
    close $parser{fd};
  }
  print FD "\n\n";
  close FD;
}

if ($help or not scalar(@files)) { showHelp() and exit; }

sub parseNsmapFile($) {
  my $file = shift;
  open FD, $file or die "Unable to open: $file.\n";
  while (<FD>) {
    if ($_ =~ m/\s*{.*}.*$/) {
      my $ns = $_;
      $ns =~ s/^\s+{\"([^\"]*)\"(.*)$/${1}/;
      $ns =~ s/[\t\n\r]//;
      if ($ns !~ m/SOAP-ENV|SOAP-ENC|{NULL, NULL, NULL, NULL}/) {
        $namespaces{$ns} = 1;
        print "Namespace: $ns probed.\n";
      }
    }
  }
  close FD;
}

foreach my $file (@nsmap_files) {
  print "Parsing nsmap: $file.\n";
  parseNsmapFile $file;
}

foreach my $file (@files) {
  print "Parsing file: $file.\n";
  parseFile($file);
}

